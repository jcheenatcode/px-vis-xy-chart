<!--
Copyright (c) 2018, General Electric

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<link rel="import" href="../polymer/polymer.html"/>
<link rel="import" href="../px-vis/px-vis-behavior-common.html"/>
<link rel="import" href="../px-vis/px-vis-behavior-d3.html"/>
<link rel="import" href="../px-vis/px-vis-behavior-renderer.html"/>
<link rel="import" href="../px-vis/px-vis-behavior-chart.html"/>
<link rel="import" href="../px-vis/px-vis-behavior-scale.html"/>
<link rel="import" href="../px-vis/px-vis-svg-canvas.html"/>
<link rel="import" href="../px-vis/px-vis-scatter.html"/>
<link rel="import" href="../px-vis/px-vis-scatter-canvas.html"/>
<link rel="import" href="../px-vis/px-vis-striping.html"/>
<link rel="import" href="../px-vis/px-vis-line-canvas.html"/>
<link rel="import" href="../px-vis/px-vis-line-svg.html"/>
<link rel="import" href="../px-vis/px-vis-axis.html"/>
<link rel="import" href="../px-vis/px-vis-multi-axis.html"/>
<link rel="import" href="../px-vis/px-vis-tooltip.html"/>
<link rel="import" href="../px-vis/px-vis-interaction-space.html"/>
<link rel="import" href="../px-vis/px-vis-register.html"/>
<link rel="import" href="../px-vis/px-vis-cursor.html"/>
<link rel="import" href="../px-vis/px-vis-clip-path.html"/>
<link rel="import" href="../px-vis/px-vis-event.html"/>
<link rel="import" href="../px-vis/px-vis-gridlines.html"/>
<link rel="import" href="../px-vis/px-vis-toolbar.html"/>
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html" />
<link rel="import" href="../px-vis/px-vis-highlight-point.html"/>
<link rel="import" href="../px-vis/px-vis-highlight-point-canvas.html"/>
<link rel="import" href="../px-vis/px-vis-annotations.html"/>
<link rel="import" href="../px-vis/px-vis-reference-curve.html"/>
<link rel="import" href="../px-vis/px-vis-central-tooltip-content.html"/>
<link rel="import" href="../px-tooltip/px-tooltip.html"/>

<link rel="import" href="css/px-vis-xy-chart-styles.html"/>


<!--
A chart which allows line drawing or scatter on arbitrary X and Y axis

### Usage

    <px-vis-xy-chart></px-vis-xy-chart>

### Styling
The following custom properties are available for styling:

Custom property | Description
----------------|-------------
  `--px-vis-axis-color` | The color for the axis lines, axis ticks, and axis tick labels
  `--px-vis-axis-title-color` | The color for the axis title
  `--px-vis-axis-inline-title-color` | The color for the axis title
  `--px-vis-axis-inline-type-color` | The color for the axis lines, axis ticks, and axis tick labels when using 'inline' labelPosition
  `--px-vis-axis-inline-box-color` | The color for the tick boxes when using 'inline' labelPosition
  |
  |
  |
  `--px-vis-cursor-line-color` | The color for the lines which track the cursor/data
  |
  |
  |
  `--px-vis-event-line-color` | The default color for the vertical lines below the icon
  `--px-vis-event-icon-color` | The default color for the event icon markers
  |
  |
  |
  `--px-vis-gridlines-color` | The color for the gridlines
  |
  |
  |
  `--px-vis-threshold-color` | The default color for a threshold
  |
  |
  |
  `--px-vis-zoom-brush-outline-color` | The stroke (border) color for the on-chart zoom/selection brush
  `--px-vis-zoom-brush-fill-color` | The fill (background) color for the on-chart zoom/selection brush
  `--px-vis-zoom-brush-fill-opacity` | The opacity for the on-chart zoom/selection brush
  |
  |
  |
  `--px-vis-register-series-name` | The color of the data series name
  `--px-vis-register-data-value` | The color of the data series value
  `--px-vis-register-box` | The color of the box around the register when a scrollbar is present
  |
  |
  |
  `--px-vis-series-color-0` | These are the colors used to represent the data series on the charts. Used in numerical order by default. Colors MUST start at 0 and cannot contain gaps between numbers.
  `--px-vis-series-color-1` |
  `--px-vis-series-color-2` |
  `--px-vis-series-color-n` |
  |
  |
  |
  `--px-tooltip-background-color` | The color of the tooltip
  `--px-tooltip-text-color` | The color of the tooltip text
  `--px-tooltip-light-background-color` | The color of the light version tooltip
  `--px-tooltip-light-text-color` | The color of the light version tooltip text
  `--px-tooltip-light-border-color`| The color of the light version tooltip border
  |
  |
  |
  `--px-vis-font-family` | The font family for all labels and text


@element px-vis-xy-chart
@blurb A chart which allows line drawing or scatter on arbitrary X and Y axis
@homepage index.html
@demo demo.html
-->

<dom-module id="px-vis-xy-chart">
  <template>
    <style include="px-vis-xy-chart-styles"></style>
    <div id="wrapper" class$="{{_chartWrapperClass}}">
      <!-- Legend -->
      <div class$="{{_registerWrapperClass}} safari-flex-fix">
        <px-vis-register
          id="register"
          class$="{{_getHideClass(hideRegister)}}"
          height="[[_registerHeight]]"
          dynamic-menu-config="[[dynamicMenuConfig]]"
          tooltip-data="[[_registerTooltipData]]"
          chart-data="[[_filteredData]]"
          complete-series-config="[[completeSeriesConfig]]"
          muted-series={{mutedSeries}}
          type="{{_registerType}}"
          x-axis-type="[[xAxisType]]"
          y-axis-type="[[yAxisType]]"
          current-page="[[_registerCurrentPage]]"
          total-pages="[[_registerTotalPages]]"
          display-page-arrows="[[_registerDisplayPageArrows]]">
        </px-vis-register>
        <div id="drawingWrapper" class="flex--col inline--flex">
          <template is="dom-if" if="[[!removeToolbar]]">
            <px-vis-toolbar
              id="toolbar"
              current-sub-config="[[toolbarSubConfig]]"
              action-config="{{actionConfig}}"
              within-chart
              chart-margin="[[_internalMargin]]"
              show-tooltip="{{_internalShowTooltip}}"
              config='{"zoom": true, "pan": true, "tooltip": true}'>
            </px-vis-toolbar>
          </template>
          <!-- Core -->
          <px-vis-tooltip
            id="tooltip"
            tooltip-data="[[tooltipData]]"
            chart-data="[[_filteredData]]"
            muted-series="[[mutedSeries]]"
            x-axis-type="[[xAxisType]]"
            y-axis-type="[[yAxisType]]"
            complete-series-config="[[completeSeriesConfig]]"
            mouse-position="[[mousePosition]]"
            hover-target="[[mouseRect]]"
            tooltip-style="light"
            hard-mute="[[hardMute]]"
            series-keys="[[_seriesKeys]]">
          </px-vis-tooltip>
          <px-vis-svg-canvas
            class="inline--flex"
            id="svg"
            width="[[width]]"
            height="[[height]]"
            margin="[[_internalMargin]]"
            canvas-context="{{canvasContext}}"
            canvas-layers="{{canvasLayers}}"
            canvas-layers-config="[[canvasLayersConfig]]"
            svg="{{svg}}"
            px-svg-elem="{{pxSvgElem}}"
            svg-lower="{{svgLower}}"
            px-svg-elem-lower="{{pxSvgElemLower}}">
              <px-vis-annotations
                slot="4"
                svg="[[svg]]"
                x="[[x]]"
                y="[[y]]"
                margin="[[_internalMargin]]"
                domain-changed="[[domainChanged]]"
                complete-series-config="[[completeSeriesConfig]]"
                annotation-data="[[annotationData]]"
                show-strong-icon="[[showStrongIcon]]">
              </px-vis-annotations>
          </px-vis-svg-canvas>
        </div>
        <px-vis-clip-path
          svg="[[layer.1]]"
          x="[[x]]"
          y="[[y]]"
          width="[[width]]"
          height="[[height]]"
          margin="[[_internalMargin]]"
          clip-path="{{clipPath}}"
          series-clip-path-y-offset="-5"
          series-clip-path="{{seriesClipPath}}">
        </px-vis-clip-path>
        <!-- scatter series -->
        <template is="dom-repeat" items="[[_seriesKeys]]">
          <template is="dom-if" if="[[_chartTypeScatter(item, completeSeriesConfig)]]" restamp>
            <template is="dom-if" if="[[renderToCanvas]]" restamp>
              <px-vis-scatter-canvas
                canvas-context="[[canvasContext]]"
                series-id="[[item]]"
                chart-data="[[_filteredData]]"
                renderer-type="filteredChartData"
                complete-series-config="[[completeSeriesConfig]]"
                width="[[width]]"
                height="[[height]]"
                margin="[[_internalMargin]]"
                x="[[x]]"
                y="[[_returnYScale(item, completeSeriesConfig, domainChanged)]]"
                clip-path
                domain-changed="[[domainChanged]]"
                muted-series="[[mutedSeries]]"
                serie-to-redraw-on-top="[[serieToRedrawOnTop]]">
              </px-vis-scatter-canvas>
            </template>
            <template is="dom-if" if="[[!renderToCanvas]]" restamp>
              <px-vis-scatter
                svg="[[layer.1]]"
                series-id="[[item]]"
                chart-data="[[_filteredData]]"
                x="[[x]]"
                y="[[_returnYScale(item, completeSeriesConfig, domainChanged)]]"
                domain-changed="[[domainChanged]]"
                muted-series="[[mutedSeries]]"
                clip-path="[[seriesClipPath]]"
                complete-series-config="[[completeSeriesConfig]]"
                serie-to-redraw-on-top="[[serieToRedrawOnTop]]">
              </px-vis-scatter>
            </template>
          </template>
          <template is="dom-if" if="[[_chartTypeLine(item, completeSeriesConfig)]]" restamp>
            <template is="dom-if" if="[[renderToCanvas]]" restamp>
              <px-vis-line-canvas
                id="lineCanvas"
                canvas-context="[[canvasContext]]"
                renderer-type="filteredChartData"
                series-id="[[item]]"
                chart-data="[[_filteredData]]"
                complete-series-config="[[completeSeriesConfig]]"
                x="[[x]]"
                y="[[_returnYScale(item, completeSeriesConfig, domainChanged)]]"
                domain-changed="[[domainChanged]]"
                show-gaps="[[showGaps]]"
                muted-series="[[mutedSeries]]"
                width="[[width]]"
                height="[[height]]"
                margin="[[_internalMargin]]"
                clip-path
                interpolation-function="[[interpolationFunction]]"
                serie-to-redraw-on-top="[[serieToRedrawOnTop]]">
              </px-vis-line-canvas>
            </template>
            <template is="dom-if" if="[[!renderToCanvas]]" restamp>
              <px-vis-line-svg
                svg="[[layer.1]]"
                series-id="[[item]]"
                chart-data="[[_filteredData]]"
                x="[[x]]"
                y="[[_returnYScale(item, completeSeriesConfig, domainChanged)]]"
                show-gaps="[[showGaps]]"
                domain-changed="[[domainChanged]]"
                muted-series="[[mutedSeries]]"
                clip-path="[[seriesClipPath]]"
                complete-series-config="[[completeSeriesConfig]]"
                interpolation-function="[[interpolationFunction]]"
                serie-to-redraw-on-top="[[serieToRedrawOnTop]]">
              </px-vis-line-svg>
            </template>
          </template>
        </template>
        <px-vis-cursor
          id="cursor"
          svg="[[layer.2]]"
          width="[[width]]"
          height="[[height]]"
          margin="[[_internalMargin]]"
          chart-data="[[_filteredData]]"
          tooltip-data="[[_registerTooltipData]]"
          complete-series-config="[[completeSeriesConfig]]"
          clip-path="[[seriesClipPath]]"
          muted-series="[[mutedSeries]]"
          hard-mute="[[hardMute]]"
          series-keys="[[_seriesKeys]]">
        </px-vis-cursor>
      </div>

      <!-- X axis -->
      <px-vis-axis
        id="xAxis"
        svg="[[layer.0]]"
        axis-type="[[xAxisType]]"
        axis="[[x]]"
        height="[[height]]"
        width="[[width]]"
        margin="[[_internalMargin]]"
        orientation="bottom"
        complete-series-config="[[completeSeriesConfig]]"
        prevent-series-bar
        domain-changed="[[domainChanged]]"
        muted-series="[[mutedSeries]]">
      </px-vis-axis>
      <!-- Y axis -->
      <px-vis-multi-axis
        id="yAxes"
        svg="[[layer.0]]"
        width="[[width]]"
        height="[[height]]"
        margin="[[_internalMargin]]"
        left-axis-size="[[leftAxisSize]]"
        right-axis-size="[[rightAxisSize]]"
        x="[[_axisX]]"
        y="[[y]]"
        domain-changed="[[_bothDomainsSet(_axisDomainChanged, domainChanged)]]"
        complete-series-config="[[_multiAxisSeriesConfig]]"
        chart-data="[[chartData]]"
        dimensions="[[dimensions]]"
        axes="[[axes]]"
        axis-config="[[yAxisConfig]]"
        append-unit-in-title
        orientation-from-dimensions
        disable-brush
        cartesian-drag-behavior
        allow-empty-title
        series-to-axes="[[seriesToAxes]]"
        muted-series="[[mutedSeries]]"
        action-config="[[_axisActionConfig]]">
      </px-vis-multi-axis>

      <template is="dom-if" if="[[!hideGridlinesX]]" restamp>
        <px-vis-gridlines
          svg="[[svgLower]]"
          axis="[[x]]"
          margin="[[_internalMargin]]"
          length="[[height]]"
          orientation="bottom"
          domain-changed="[[domainChanged]]">
        </px-vis-gridlines>
      </template>

      <template is="dom-if" if="[[_showHorizontalGrid(hideGridlinesY, axes, y, matchTicks)]]" restamp>
        <px-vis-gridlines
          svg="[[svgLower]]"
          axis="[[_returnGridAxis(domainChanged)]]"
          margin="[[_internalMargin]]"
          length="[[width]]"
          orientation="left"
          domain-changed="[[domainChanged]]">
        </px-vis-gridlines>
      </template>

      <px-vis-interaction-space
        id="interactionSpace"
        svg="[[layer.3]]"
        width="[[width]]"
        height="[[height]]"
        margin="[[_internalMargin]]"
        x="[[x]]"
        y="[[y]]"
        domain-changed="[[domainChanged]]"
        use-quadtree
        series-keys="[[_seriesKeys]]"
        chart-data="[[_filteredData]]"
        chart-id="[[chartId]]"
        tooltip-data="{{tooltipData}}"
        crosshair-data="{{crosshairData}}"
        default-empty-data="[[defaultEmptyData]]"
        generating-crosshair-data="{{generatingCrosshairData}}"
        extents-data="{{extentsData}}"
        x-axis-type="[[xAxisType]]"
        y-axis-type="[[yAxisType]]"
        complete-series-config="[[completeSeriesConfig]]"
        mouse-rect="{{mouseRect}}"
        time-data="[[timeData]]"
        action-config="{{actionConfig}}"
        show-tooltip="{{_computedShowTooltip}}"
        selection-type="[[selectionType]]"
        prevent-web-worker-synchronization="[[preventWebWorkerSynchronization]]"
        ww-data-sync-counter="[[wwDataSyncCounter]]"
        extents-action="{{extentsAction}}"
        hard-mute="[[hardMute]]"
        muted-series="[[mutedSeries]]"
        log-base="[[logBase]]">
      </px-vis-interaction-space>

      <px-vis-event
        svg="[[layer.0]]"
        event-data="[[eventData]]"
        x-axis-type="[[xAxisType]]"
        height="[[height]]"
        margin="[[_internalMargin]]"
        x="[[x]]"
        domain-changed="[[domainChanged]]"
        event-config="[[eventConfig]]"
        clip-path="[[clipPath]]"
        resources="[[resources]]"
        language="[[language]]"
        formats="[[formats]]">
      </px-vis-event>
    </div>

    <template id="highlighterDomIf" is="dom-if" if="[[renderToCanvas]]" restamp on-dom-change="_highlighterConfigChanged">
      <px-vis-highlight-point-canvas
        id="highlighterCanvas"
        width="[[width]]"
        height="[[height]]"
        margin="[[_internalMargin]]"
        canvas-context="[[canvasLayers.highlighter]]"
        canvas-layers-config="{{canvasLayersConfig}}"
        layers-to-mask="[[canvasContext]]"
        clip-path
        x="[[x]]"
        y="[[y]]"
        domain-changed="[[domainChanged]]"
        time-data="[[timeData]]"
        complete-series-config="[[completeSeriesConfig]]"
        series-keys="[[_seriesKeys]]"
        chart-data="[[chartData]]"
        generating-crosshair-data="[[generatingCrosshairData]]"
        default-empty-data="{{defaultEmptyData}}"
        crosshair-data="[[crosshairData]]"
        tooltip-data="{{tooltipData}}"
        hard-mute="[[hardMute]]"
        muted-series="[[mutedSeries]]">
      </px-vis-highlight-point-canvas>
    </template>
    <template is="dom-if" if="[[!renderToCanvas]]" restamp on-dom-change="_highlighterConfigChanged">
      <px-vis-highlight-point
        id="highlighter"
        svg="[[layer.2]]"
        layers-to-mask="[[layer.1]]"
        x="[[x]]"
        y="[[y]]"
        domain-changed="[[domainChanged]]"
        time-data="[[timeData]]"
        series-keys="[[_seriesKeys]]"
        complete-series-config="[[completeSeriesConfig]]"
        chart-data="[[chartData]]"
        generating-crosshair-data="[[generatingCrosshairData]]"
        crosshair-data="[[crosshairData]]"
        default-empty-data="{{defaultEmptyData}}"
        tooltip-data="{{tooltipData}}"
        clip-path="[[seriesClipPath]]"
        hard-mute="[[hardMute]]"
        muted-series="[[mutedSeries]]">
      </px-vis-highlight-point>
    </template>

    <px-vis-striping
            id="starsAndStripes"
            width="[[width]]"
            height="[[height]]"
            margin="[[_internalMargin]]"
            canvas-context="[[canvasLayers.striping]]"
            canvas-layers-config="{{canvasLayersConfig}}"
            x="[[x]]"
            domain-changed="[[domainChanged]]"
            clip-path
            stripe-config="[[stripeConfig]]"
            stripe-data="[[stripeData]]">
    </px-vis-striping>

    <template id="ref" is="dom-if" if="[[_showRef(referenceData.*)]]" restamp>
      <px-vis-reference-curve
        id="referenceCurve"
        chart-id="[[chartId]]"
        svg="[[layer.2]]"
        x="[[x]]"
        y="[[y]]"
        domain-changed="[[domainChanged]]"
        reference-config="[[referenceConfig]]"
        reference-data="[[referenceData]]"
        clip-path="[[seriesClipPath]]">
      </px-vis-reference-curve>
    </template>

    <px-tooltip
      id="centralTooltip"
      smart-orientation
      ignore-target-events
      orientation="[[tooltipOrientation]]">
      <px-vis-central-tooltip-content
        resources="[[resources]]"
        use-key-if-missing="[[useKeyIfMissing]]"
        language="[[language]]"
        first-date-time-format="[[firstDateTimeFormat]]"
        second-date-time-format="[[secondDateTimeFormat]]"
        separator="[[separator]]"
        timezone="[[timezone]]">
      </px-vis-central-tooltip-content>
    </px-tooltip>
  </template>
</dom-module>

<script>
  Polymer({

    is: 'px-vis-xy-chart',

    behaviors: [
      PxVisBehavior.observerCheck,
      PxVisBehaviorScale.scale,
      PxVisBehaviorD3.svg,
      PxVisBehaviorD3.axes,
      PxVisBehaviorD3.selectedDomain,
      PxVisBehaviorD3.clipPath,
      PxVisBehavior.dataset,
      PxVisBehavior.mutedSeries,
      PxVisBehavior.sizing,
      PxVisBehavior.tooltipData,
      PxVisBehavior.extentsData,
      PxVisBehavior.chartExtents,
      PxVisBehavior.axisTypes,
      PxVisBehavior.events,
      PxVisBehavior.completeSeriesConfig,
      PxVisBehaviorChart.chartCommon,
      PxVisBehaviorChart.saveImage,
      PxVisBehaviorChart.subConfiguration,
      PxVisBehaviorChart.timeFiltering,
      PxVisBehaviorD3.domainUpdate,
      PxVisBehaviorChart.registerPositioning,
      PxVisBehaviorChart.chartAutoResize,
      PxVisBehaviorChart.layers,
      PxColorsBehavior.dataVisColorTheming,
      PxVisBehavior.serieToRedrawOnTop,
      PxVisBehavior.dynamicMenuConfig,
      PxVisBehavior.actionConfig,
      PxVisBehaviorChart.zooming,
      PxVisBehaviorChart.actionRequest,
      PxVisBehaviorChart.toolbarSubConfig,
      PxVisBehaviorChart.noDebounceOnPanning,
      PxVisBehaviorChart.chartToolbarConfig,
      PxVisBehaviorChart.multiAxis,
      PxVisBehaviorD3.lineGaps,
      PxVisBehaviorChart.showTooltip,
      PxVisBehavior.muteUnmuteSeries,
      PxVisBehavior.zoomSelection,
      PxVisBehaviorChart.tooltipFollowMouseCalculation,
      PxVisBehavior.selectionType,
      PxVisBehaviorD3.canvasContext,
      PxVisBehaviorD3.renderToCanvas,
      PxVisBehaviorChart.highlighterConfigs,
      PxVisBehaviorChart.mouseCusorConfig,
      PxVisBehavior.crosshairData,
      PxVisBehaviorChart.webWorkerSynchronization,
      Polymer.AppLocalizeBehavior,
      PxVisBehavior.stripProperties,
      PxVisBehaviorRenderer.base,
      PxVisBehavior.annotationData,
      PxVisBehaviorChart.cursorConfig,
      PxVisBehaviorChart.registerPagnation,
      PxVisBehaviorChart.sizeVerticalRegister,
      PxVisBehavior.referenceCurveProps,
      PxVisBehaviorChart.centralTooltip

    ],
    properties: {
      /**
       * Configuration object used to customize the X axis cosmetic properties.
       * Please refer to px-vis-axis (https://github.com/PredixDev/px-vis) for a list of supported proerties
       *
       */
      xAxisConfig: {
        type: Object
      },
      /**
       * Configuration object used to customize the Y axis cosmetic properties.
       * Please refer to px-vis-axis (https://github.com/PredixDev/px-vis) for a list of supported proerties
       *
       */
      yAxisConfig: {
        type: Object
      },
      /**
       * Configuration object used to customize the tooltip.
       * Please refer to px-vis-tooltip (https://github.com/PredixDev/px-vis) for a list of supported properties.
       * Most interesting properties include:
       * -width
       * -height
       *
       */
      tooltipConfig: {
        type: Object
      },
      /**
       * Configuration object used to customize the tooltip.
       * Please refer to px-vis-register (https://github.com/PredixDev/px-vis) for a list of supported properties.
       * Most interesting properties include:
       * -width
       * -height
       *
       */
      registerConfig: {
        type: Object
      },
      mouseRect: {
        type: Object
      },
      /**
       * Whether to hide the gridlines perpendicular to the X axis
       */
      hideGridlinesX: {
        type: Boolean,
        value: false
      },
      /**
       * Whether to hide the gridlines perpendicular to the Y axis
       */
      hideGridlinesY: {
        type: Boolean,
        value: false
      },

      _internalMargin: {
        type: Object,
        notify: true
      },

      /**
       * A boolean to specify if the axis ticks should align (which affects
       * their individual range). Default (false) is for each have their own
       * ranges and tick marks may not align
       * Only useful if using multiple axis
       */
      matchTicks: {
        type: Boolean,
        value: false
      },

      _axisActionConfig: {
        type: Object,
        notify: true,
        computed: '_computeAxisActionConfig(dimensions.*, _isAttached)'
      },

      /**
       * List of key/values to be included for translating this component
       */
      resources: {
        type: Object
      },
      /**
      * set a default for localizing
      */
      language: {
        type: String,
        value: 'en'
      },
      /**
      * Use the key for localization if value for  language is missing. Should
      * always be true for  our components
      */
      useKeyIfMissing: {
        type: Boolean,
        value: true
      },

      /**
       * Holder object for the stripe highlight
       */
      _stripeHighlight: {
        type: Object
      },

      /**
       * Holder object for the stripe handles
       */
      _stripeController: {
        type: Object
      },
      /**
       * Holder object for the stripe brush
       */
      _stripeBrush: {
        type: Object
      },

      /**
       * The current data index value for the active stripe
       */
      _stripeDataIndex: {
        type: Number,
        value: null
      },
      
      /**
      * This is help us temporarily hide & show the toolbar
      */
      removeToolbar: {
          type: Boolean,
          value: true
      }
    },
    observers: [
      '_xAxisConfigChanged(xAxisConfig.*)',
      '_toolbarConfigChanged(toolbarConfig.*)',
      '_createLayersOnce(svg, numberOfLayers)',
      '_highlighterConfigChanged(highlighterConfig.*)',
      '_mouseCursorConfigChanged(mouseCursorConfig.*)',
      '_cursorConfigChanged(cursorConfig.*)',
      '_interactionSpaceConfigChanged(interactionSpaceConfig.*)',
      '_registerConfigChanged(registerConfig.*)',
      '_tooltipConfigChanged(tooltipConfig.*)',

      '_calcAxes(completeSeriesConfig.*)',
      '_calcAxes(leftAxisSize, rightAxisSize)',
      '_calcMargins(margin.*, numRightAxes, numLeftAxes)',
      '_setXScale(width, _internalMargin)',
      '_setMultiYScale(height, _internalMargin, axes.*)',
      '_setDomainCaller(wwDataSyncCounter, x, y, dataExtents, seriesToAxes.*)',
      '_setDomainCaller(x, y, dataExtents, seriesToAxes.*)',
      '_setDomainCaller(x, y, chartExtents, dataExtents)',
      '_updateDomain(selectedDomain)',
      '_keepDataInSync(_filteredData.*, chartId)',
      '_seriesKeysChanged(_seriesKeys.*)',
      '_langChanged(language)',
      '_mutedChanged(mutedSeries.*, hardMute)',
      '_tooltipDataUpdated(tooltipData.*)',

      //renderer
      '_renderFilteredChartData(domainChanged, canvasContext, _filteredData.*, completeSeriesConfig.*, preventInitialDrawing, renderToCanvas)',
      '_renderOnMute(mutedSeries.*)',
      '_renderHighlight(domainChanged, canvasLayers.highlighter, completeSeriesConfig.*, preventInitialDrawing)',
      '_renderSeriesOnTop(serieToRedrawOnTop)'
    ],

    listeners: {
        'px-vis-interaction-space-mouse-coords': '_stripeCoords',
    },

    created: function() {
      this._tooltipCalcHoverTargetId = 'wrapper';
      this._wwSyncDataPropName = '_filteredData';
    },

    ready: function() {
      this.set('_verticalRegisterDrawingCanvasId', 'svg');
      
      if(!this.removeToolbar)
        this.set('_verticalRegisterHeightDeductions', ['toolbar']);

      this.set('numberOfLayers',5);

        //add in our striping option
        this._extentsDataRoutes['stripe'] = '_createStripe';
    },
    attached: function() {
      this._isAttached = true;
    },

    _xAxisConfigChanged: function(conf) {
      if(this.hasUndefinedArguments(arguments)) {
        return;
      }

      this._applyConfigToElement(this.xAxisConfig, this.$.xAxis);
    },

    _tooltipConfigChanged: function(conf) {
      if(this.hasUndefinedArguments(arguments)) {
        return;
      }

      this._applyConfigToElement(this.tooltipConfig, this.$.tooltip);
    },
    _registerConfigChanged: function(conf) {
     if(this.hasUndefinedArguments(arguments)) {
       return;
     }

      this._applyConfigToElement(this.registerConfig, this.$.register);
    },
    _toolbarConfigChanged: function(conf) {
     if(this.hasUndefinedArguments(arguments)) {
       return;
     }

      this._applyConfigToElement(this.toolbarConfig, this.$.toolbar);
    },
    _interactionSpaceConfigChanged: function(interactionSpaceConfig) {
     if(this.hasUndefinedArguments(arguments)) {
       return;
     }

      this._applyConfigToElement(this.interactionSpaceConfig, this.$.interactionSpace)
    },

    _highlighterConfigChanged: function() {

      var elem = this.renderToCanvas ? this.$$('#highlighterCanvas') : this.$$('#highlighter');
      if(elem && this._doesObjHaveValues(this.highlighterConfig)) {
        this._applyConfigToElement(this.highlighterConfig, elem);
      }
    },
    _cursorConfigChanged: function(conf) {
     if(this.hasUndefinedArguments(arguments)) {
       return;
     }

      this._applyConfigToElement(this.cursorConfig, this.$.cursor);
    },
    _mouseCursorConfigChanged: function(conf) {
     if(this.hasUndefinedArguments(arguments)) {
       return;
     }

      this._applyConfigToElement(this.mouseCursorConfig, this.$.mouseCursor);
    },

    _seriesKeysChanged: function() {
      if(this.hasUndefinedArguments(arguments)) {
        return;
      }

      //make sure we clean the canvas so that ols series are removed
      if(this.renderToCanvas && this.canvasContext && this.canvasContext.pxClearCanvas) {
        this.canvasContext.pxClearCanvas();
      }
    },

    _resizeCalculations: function() {

      //make sure we are not preventing resize in case it changed while debouncing
      if(this.preventResize) {
        return;
      }
      var wrapperRect = this.$.wrapper.getBoundingClientRect(),
          registerRect = this.$.register.getBoundingClientRect(),
          toolbarRect = (this.removeToolbar) ? {height:0, width: 0} : this.$.toolbar.getBoundingClientRect(),
          heightDeduct = 0,
          widthDeduct = 0;


      if(this.$.register.type === 'horizontal') {
        heightDeduct += registerRect.height;
      } else {
        widthDeduct += registerRect.width;
      }

      if(!this.removeToolbar)
        heightDeduct += toolbarRect.height;

      this.set('width', Math.max(wrapperRect.width - widthDeduct, 0));
      this.set('height', Math.max(wrapperRect.height - heightDeduct, 0));
      
      if(!this.removeToolbar)
        this._computeVerticalRegisterHeight([toolbarRect.height]);
    },

    /**
     * Overwrites default margins based on settings
     *
     * @method _calcMargins
     */
    _calcMargins:function() {
     if(this.hasUndefinedArguments(arguments)) {
       return;
     }

      this.debounce('_calcMargin', function() {
        var margin,
            topMargin = 25,
            rightMargin = 10,
            bottomMargin = 10,
            leftMargin = 10;

        // if the dev didnt set the margin, then calc it
        if(JSON.stringify(this._defaultMargin) === JSON.stringify(this.margin)) {
          if(this.xAxisLocation === 'bottom') {
            bottomMargin = 40;
          } else if(this.xAxisLocation === 'top') {
            topMargin = 40;
          }

          if(this.yAxisLocation === 'left') {
            leftMargin = 50;
          } else if(this.yAxisLocation === 'right') {
            rightMargin = 50;
          }

          margin = {
            'top': topMargin,
            'right': rightMargin,
            'bottom': bottomMargin,
            'left': leftMargin
          };

          this._calcMultiMargins(margin, 50, 50);

        } else { //is dev set, use it
          margin = {
            'top': Number(this.margin.top) || Number(this.margin.top) === 0 ? Number(this.margin.top) : topMargin,
            'right': Number(this.margin.right) || Number(this.margin.right) === 0 ? Number(this.margin.right) : rightMargin,
            'bottom': Number(this.margin.bottom) || Number(this.margin.bottom) === 0 ? Number(this.margin.bottom) : bottomMargin,
            'left':  Number(this.margin.left) || Number(this.margin.left) === 0 ? Number(this.margin.left) : leftMargin
          };

          // FIXME
          // assume the margin is the side for one axis. Might not be a good assumption. Rethink this
          this._calcMultiMargins(margin, margin.left, margin.right);
        }

        this.set('_internalMargin', margin);

      }, 5);
    },

    _showHorizontalGrid: function(hideGrid, axes, y, matchTicks) {
      if(this.hasUndefinedArguments(arguments)) {
        return;
      }

      if(hideGrid) {
        return false;
      }

      if(this.axes.length > 1 && !matchTicks) {
        return false;
      }

      return true;
    },

    _returnGridAxis: function() {
      if(this.hasUndefinedArguments(arguments)) {
        return;
      }

        return this.y[this.axes[0]];
    },

    _returnXDomain: function() {
      if(this.domainChanged) {
        return this.x.domain();
      }
    },

    _mutedChanged: function() {
      if(this.hasUndefinedArguments(arguments)) {
        return;
      }

      if(this.hardMute === true) {
        this._setDomainCaller();
      }
    },

    _setDomainCaller: function() {
      if(this.hasUndefinedArguments(arguments)) {
        return;
      }

      if(this._doesObjHaveValues(this.seriesToAxes)) {
        this._setDomain();
      }
    },

    _bothDomainsSet: function() {
      if(this.hasUndefinedArguments(arguments)) {
        return;
      }

      if(this.domainChanged && this._axisDomainChanged) {
		  // check if 'this.$.yAxes.domainChanged' is undefined use
		  // 'this.domainChanged' to initialize 'domainChanged' property on 'px-vis-multi-axis'
		  return this.$.yAxes.domainChanged ? (this.$.yAxes.domainChanged + 1) : (this.domainChanged + 1);
      }
    },

    _renderOnMute: function() {
      if(!this.domainChanged || !this.canvasContext) {
        return;
      }

      if(this.hardMute) {
        this.canvasContext.pxClearCanvas();
        return;
      }

      this._renderFilteredChartData();
    },

    _computeAxisActionConfig: function() {
      if(this.hasUndefinedArguments(arguments)) {
        return;
      }

      var conf;

      conf = this.dimensions.length > 2 ? {
          "mouseout": null,
          "mousemove": null,
          "mousedown": 'callAxisDrag',
          "mouseup": 'callAxisDrag'
        } : {
          "mouseout": null,
          "mousemove": null,
          "mousedown": null,
          "mouseup": null
        };

      return conf;
    },
    _langChanged: function() {
     if(this.hasUndefinedArguments(arguments)) {
       return;
     }

      //recreate X and Y in case d3 locale changed
      this._recreateScales(this.width, this.height, this._internalMargin);
    },

    /**
     * Creates a new stripe: checks that we have the necessary values and vars
     *
     */
    _createStripe: function() {
        if(this.extentsAction !== 'stripe') {
            return;
        }

        if(!this.stripeType) {
            console.warn("No stripe type specified. Aborting creation");
            return;
        }

        if(typeof this.stripeData[this.stripeType] === 'undefined') {
            this.stripeData[this.stripeType] = [];
        }

        this._addStripeToData();
    },

    /**
     * Addes a new stripe to the dataset
     *
     */
    _addStripeToData: function() {
        var indexes = [],
            exts = this._checkForOverlap(this.extentsData.eX, indexes);

        if(exts) {
            this._deleteRedundantStripes(indexes);
            // TODO order set
            this.push('stripeData.' + this.stripeType, exts);
        }

        console.log(this.stripeData);
    },

    /**
     * Look through our stripes and make sure they do not overlap
     *
     */
    _checkForOverlap: function(exts, indexes) {
        var d = this.stripeData[this.stripeType],
            tMin = exts[0],
            tMax = exts[exts.length - 1];

        for(var i=0; i<d.length; i++) {
            // new box fits wholly inside old box
            if(tMin >= d[i][0] && tMax <= d[i][1]) {
                tMin = d[i][0];
                tMax = d[i][1];

                // assume we dont need to check anymore because everything else has already been checked for overlap
                return false;

                // if our new box fully encompasses an old box
            } else if(tMin < d[i][0] && tMax > d[i][1]) {
                indexes.push(i);

                // our new box overlaps lower end of old box
            } else if(tMin <= d[i][0] && tMax >= d[i][0] && tMax <= d[i][1]) {
                tMax = d[i][1];
                indexes.push(i);

                // our new box overlaps upper end of old box
            } else if(tMin >= d[i][0] && tMin <= d[i][1] && tMax >= d[i][1]) {
                tMin = d[i][0];
                indexes.push(i);
            }
        }

        return [ tMin, tMax ];
    },

    /**
     * Removes overlapped stripes from the dataset
     *
     */
    _deleteRedundantStripes: function(indexes) {
        for(var i = indexes.length - 1; i > -1; i--) {
            this.stripeData[this.stripeType].splice(indexes[i], 1);
        }
    },

    /**
     * Debounces mousemove for calc stripe coords
     *
     */
    _stripeCoords: function(evt) {
        this.debounce('stripeHover', function() {
            this._stripeCoordsDebounced(evt);
        }, 10);
    },

    /**
     * On mousemove from the IS, calcs the mouse pos and if we are hovering over a stripe.
     *
     */
    _stripeCoordsDebounced: function(evt) {
        if(this.extentsAction !== 'stripe') {
            return;
        }

        if(!this.stripeData[this.stripeType] || this.stripeData[this.stripeType].length === 0) {
            return;
        }

        if(this._isObjEmpty(this._stripeController)) {
            this._buildStripeHandles();
        }

        var mousePos = evt.detail.mouse,
            // for time related axis
            t = (this.xAxisType === "ordinal") ? this.$.interactionSpace._getOrdinalValue(true,mousePos[0]) : this.x.invert(mousePos[0]),
            dataset = this.stripeData[this.stripeType],
            found = false;

        for(var i=0; i <dataset.length; i++) {
            // check if single vector
            if(!dataset[i][1] && dataset[i][1] !== 0) {
                if(~~this.x(dataset[i][0]) === ~~mousePos[0]) {
                    this._hoverSingleVectorStripe(i);
                    break;
                }

                // checks if we are within the range of a stripe
            } else if(dataset[i][0] <= t && dataset[i][1] >= t) {
                this._hoverEditableStripe(i);

                //there should only be one, so if found, stop checking
                break;
            }
        }
    },

    /**
     * Removes a stripe from the dataset
     *
     */
    _deleteStripe: function() {
        this.splice('stripeData.' + this.stripeType, this._stripeDataIndex, 1);
        this._hideStripeHover();
    },

    /**
     * When a stripe is hovered over, set up our brush to capture other interactions
     *
     */
    _hoverEditableStripe: function(index) {
        var x0 = this.x(this.stripeData[this.stripeType][index][0]),
            x1 = this.stripeData[this.stripeType][index][1] || this.stripeData[this.stripeType][index][1] === 0 ? this.x(this.stripeData[this.stripeType][index][1]) : this.x(this.stripeData[this.stripeType][index][0] + 1),
            w = x1 - x0;

        this._stripeHighlight
            .attr('stroke', this.stripeConfig[this.stripeType]['fillColor'])
            .on("click", this._deleteStripe.bind(this))
            .attr('pointer-events', 'all')
            .style('visibility', null);

        this._stripeController.select("rect.overlay")
            .attr('pointer-events', 'all');

        this._stripeController
            .on("click", this._deleteStripe.bind(this))
            //turn off when you leave out the top of bottomv
            .on("mouseleave", this._hideStripeHover.bind(this))
            //turn off when you leave out the sides
            .on("mousemove", function() {
                if(Polymer.dom(Px.d3.event).path[0].classList.contains('overlay')) {
                    this._hideStripeHover();
                }
            }.bind(this))
            .call(this._stripeBrush.move, [x0, x1]);

        this._stripeBrush
            .on("start", this._stripeEditStart.bind(this))
            .on("end", this._stripeEditEnd.bind(this));

        this._stripeDataIndex = index;

    },

    _hoverSingleVectorStripe: function(index) {
        const x0 = this.x(this.stripeData[this.stripeType][index][0]);
        const _this = this;
        this.layer[4].append("line")
            .attr('x1', x0)
            .attr('x2', x0)
            .attr('y1', this._internalMargin.top)
            .attr('y2', this.height - this._internalMargin.top - this._internalMargin.bottom)
            .attr('stroke', this.stripeConfig[this.stripeType]['fillColor'])
            .attr('stroke-dasharray', this.stripeConfig[this.stripeType]['dash'])
            .attr('stroke-width', 4)
            .attr('shape-rendering','crispEdges')
            .attr('pointer-events', 'all')
            .on('click', function() {
                _this._deleteStripe();
                this.remove();
            })
            .on('mouseleave', function() { this.remove(); });
    },

    /**
     * builds the brush for capturing other stripe interactions
     *
     */
    _buildStripeHandles: function() {
        var h = Math.max(this.height - this._internalMargin.bottom - this._internalMargin.top, 1),
            xRange = this.x.range(),
            range = [
                [xRange[0], 0],
                [xRange[1], h]
            ],
            overlay;

        this._stripeBrush = Px.d3.brushX()
            .extent(range)
            .handleSize(6);

        this._stripeController = this.layer[4].append("g")
            .attr("class", "brush")
            .call(this._stripeBrush)
            .call(this._stripeBrush.move, null);

        // Need to turn off pointer events so the interaction space rect gets them.
        this._stripeController.select("rect.overlay").attr('pointer-events', 'none')

        this._stripeHighlight = this._stripeController.select("rect.selection")
            .attr('fill', 'transparent')
            .attr('stroke-width', 4)
            .attr('shape-rendering','crispEdges');

    },

    /**
     * Hides the brush for strip edits
     *
     */
    _hideStripeHover: function() {
        // turn off listeners before moving brush
        this._stripeBrush
            .on("start", null)
            .on("brush", null)
            .on("end", null);

        this._stripeHighlight.style('visibility', 'hidden');

        this._stripeController
            .on("click", null)
            .on("mouseout", null)
            .call(this._stripeBrush.move, null);

        this._stripeController.select("rect.overlay").attr('pointer-events', 'none')

    },

    /**
     * Runs when a brush is first interacted with
     *
     */
    _stripeEditStart: function() {
        // kill listener so it doesnt activate while brushing
        this._stripeController
            .on("mouseout", null);
    },

    /**
     * When they are done interacting with a brush, calc its new size
     *
     */
    _stripeEditEnd: function() {
        this.debounce('stripeBrushed', function () {
            var brushExt = Px.d3.brushSelection(this._stripeController.node());

            if(brushExt) {
                this._deleteStripe();

                // mock a extentsDataChange to pass data to the stripe creation fn
                if(!this.extentsData) { this.extentsData = {}; }

                if(this.xAxisType === "ordinal") {
                    var brushRange = this.$.interactionSpace._getOrdinalRange(true,brushExt[0],brushExt[1]);
                    this.extentsData.eX = [brushRange[0], brushRange[brushRange.length - 1]]
                } else {
                    this.extentsData.eX = [this.x.invert(brushExt[0]).getTime(), this.x.invert(brushExt[1]).getTime()];
                }

                this._createStripe();
            }
        }, 10);
    },

    _showRef: function() {
      return this.referenceData && this.referenceData.length ? true : false;
    }
  });
</script>